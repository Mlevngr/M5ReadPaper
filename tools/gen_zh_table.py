#!/usr/bin/env python3
"""
tools/gen_zh_table.py

Read tools/zh_conv_table.csv (4-column): Source,Target,SourceType,TargetType
and emit src/text/zh_conv_table_generated.cpp containing a single pair table
plus two index arrays (trad-sorted and simp-sorted) and an extern C lookup
function zh_conv_embedded_lookup(key, mode).

CSV rules:
 - Only rows where SourceType/TargetType clearly indicate 简体/繁体 are used.
 - The generated pairs are stored as (traditional, simplified).
 - If the traditional string contains spaces, only the first token is kept.
"""

import csv
import os
import sys


DEF_CSV = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'tools', 'zh_conv_table.csv')
OUT_CPP = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'src', 'text', 'zh_conv_table_generated.cpp')


def is_simplified(label: str) -> bool:
    return '简体' in label


def is_traditional(label: str) -> bool:
    return '繁体' in label


def read_pairs(csv_path):
    pairs = []  # (trad, simp)
    total_lines = 0
    with open(csv_path, 'r', encoding='utf-8') as f:
        reader = csv.reader(f)
        header_seen = False
        for row in reader:
            if not row or all(not c.strip() for c in row):
                continue
            total_lines += 1
            if not header_seen:
                hdr0 = row[0].strip().lower()
                # Skip header-like first line if it contains 'source' or 'target'
                if 'source' in hdr0 or 'target' in hdr0:
                    header_seen = True
                    continue
            # Ensure at least 4 columns
            while len(row) < 4:
                row.append('')
            source = row[0].strip()
            target = row[1].strip()
            stype = row[2].strip()
            ttype = row[3].strip()
            if not source or not target:
                continue
            
            # 去掉空格分隔的备选项，只保留第一个
            if ' ' in source:
                source = source.split(' ', 1)[0]
            if ' ' in target:
                target = target.split(' ', 1)[0]
            
            trad = ''
            simp = ''
            if is_simplified(stype) and is_traditional(ttype):
                simp = source
                trad = target
            elif is_traditional(stype) and is_simplified(ttype):
                trad = source
                simp = target
            else:
                # can't determine direction
                continue
            pairs.append((trad, simp))
    return pairs, total_lines


def codepoint_key(s):
    return tuple(ord(ch) for ch in s)


def emit_cpp(pairs, out_path):
    # Deduplicate by traditional key, keep first occurrence
    seen = set()
    base = []
    for trad, simp in pairs:
        if trad in seen:
            continue
        seen.add(trad)
        base.append((trad, simp))

    N = len(base)
    indices_trad = list(range(N))
    indices_simp = list(range(N))
    indices_trad.sort(key=lambda i: codepoint_key(base[i][0]))
    indices_simp.sort(key=lambda i: codepoint_key(base[i][1]))

    # Build single-character index for BMP (0x0000 - 0xFFFF)
    # zh_single_index[cp] == 0 means no mapping; otherwise stores pair_index+1
    SINGLE_SIZE = 0x10000
    single_index = [0] * SINGLE_SIZE
    for idx, (trad, simp) in enumerate(base):
        # If trad key is a single codepoint, map it
        if len(trad) == 1:
            cp = ord(trad)
            if cp < SINGLE_SIZE:
                single_index[cp] = idx + 1

    os.makedirs(os.path.dirname(out_path), exist_ok=True)
    with open(out_path, 'w', encoding='utf-8') as out:
        out.write('// Auto-generated by tools/gen_zh_table.py\n')
        out.write('#include <cstddef>\n#include <cstdint>\n#include <cstring>\n\n')
        out.write('struct zh_conv_pair_t { const char* trad; const char* simp; };\n\n')
        out.write(f'static const zh_conv_pair_t zh_conv_pairs[{N}] = {{\n')
        for trad, simp in base:
            t = trad.replace('\\', '\\\\').replace('"', '\\"')
            s = simp.replace('\\', '\\\\').replace('"', '\\"')
            out.write(f'    {{ "{t}", "{s}" }},\n')
        out.write('};\n\n')

        out.write(f'static const uint32_t zh_conv_indices_trad[{N}] = {{\n')
        for i, idx in enumerate(indices_trad):
            if i % 16 == 0:
                out.write('    ')
            out.write(f'{idx}, ')
            if i % 16 == 15:
                out.write('\n')
        out.write('\n};\n\n')

        out.write(f'static const uint32_t zh_conv_indices_simp[{N}] = {{\n')
        for i, idx in enumerate(indices_simp):
            if i % 16 == 0:
                out.write('    ')
            out.write(f'{idx}, ')
            if i % 16 == 15:
                out.write('\n')
        out.write('\n};\n\n')

        # Emit single-index table (BMP only) for fast-path single-character lookup
        out.write(f'static const uint32_t zh_single_index[{SINGLE_SIZE}] = {{\n')
        for i in range(SINGLE_SIZE):
            if i % 16 == 0:
                out.write('    ')
            out.write(f'{single_index[i]}, ')
            if i % 16 == 15:
                out.write('\n')
        out.write('\n};\n\n')

        out.write('// mode: 1 = trad->simp, 2 = simp->trad\n')
        out.write('extern "C" const char* zh_conv_embedded_lookup(const char* key, uint8_t mode) {\n')
        out.write('    if (!key) return nullptr;\n')
        out.write('    // Fast-path: if key is a single Unicode codepoint in BMP, use zh_single_index O(1) lookup\n')
        out.write('    size_t klen = std::strlen(key);\n')
        out.write('    if (klen > 0 && klen <= 4) {\n')
        out.write('        unsigned char c0 = (unsigned char)key[0];\n')
        out.write('        uint32_t cp = 0; bool single_cp = false;\n')
        out.write('        if ((c0 & 0x80) == 0) { if (klen == 1) { cp = c0; single_cp = true; } }\n')
        out.write('        else if ((c0 & 0xE0) == 0xC0) { if (klen == 2) { cp = ((c0 & 0x1F) << 6) | ((unsigned char)key[1] & 0x3F); single_cp = true; } }\n')
        out.write('        else if ((c0 & 0xF0) == 0xE0) { if (klen == 3) { cp = ((c0 & 0x0F) << 12) | (((unsigned char)key[1] & 0x3F) << 6) | ((unsigned char)key[2] & 0x3F); single_cp = true; } }\n')
        out.write('        else if ((c0 & 0xF8) == 0xF0) { if (klen == 4) { cp = ((c0 & 0x07) << 18) | (((unsigned char)key[1] & 0x3F) << 12) | (((unsigned char)key[2] & 0x3F) << 6) | ((unsigned char)key[3] & 0x3F); single_cp = true; } }\n')
        out.write('        if (single_cp && cp < 0x10000) {\n')
        out.write('            uint32_t id = zh_single_index[cp];\n')
        out.write('            if (id) { const zh_conv_pair_t &p = zh_conv_pairs[id-1]; return (mode == 1) ? p.simp : p.trad; }\n')
        out.write('        }\n')
        out.write('    }\n')
        out.write('    const uint32_t* idx = nullptr; size_t N = 0; bool search_trad = true;\n')
        out.write('    if (mode == 1) { idx = zh_conv_indices_trad; N = sizeof(zh_conv_indices_trad)/sizeof(uint32_t); search_trad = true; }\n')
        out.write('    else if (mode == 2) { idx = zh_conv_indices_simp; N = sizeof(zh_conv_indices_simp)/sizeof(uint32_t); search_trad = false; }\n')
        out.write('    else return nullptr;\n')
        out.write('    size_t lo = 0, hi = (N==0?0:N-1);\n')
        out.write('    while (lo <= hi && N) {\n')
        out.write('        size_t mid = (lo + hi) >> 1;\n')
        out.write('        const zh_conv_pair_t &p = zh_conv_pairs[idx[mid]];\n')
        out.write('        const char* probe = search_trad ? p.trad : p.simp;\n')
        out.write('        int cmp = std::strcmp(key, probe);\n')
        out.write('        if (cmp == 0) { return search_trad ? p.simp : p.trad; }\n')
        out.write('        if (cmp < 0) { if (mid==0) break; hi = mid - 1; } else lo = mid + 1;\n')
        out.write('    }\n')
        out.write('    return nullptr;\n')
        out.write('}\n')

    print(f'Wrote {out_path} with {N} pairs')


if __name__ == '__main__':
    pairs, lines = read_pairs(DEF_CSV)
    print(f'Read {lines} logical CSV lines, extracted {len(pairs)} pairs')
    emit_cpp(pairs, OUT_CPP)
    sys.exit(0)
